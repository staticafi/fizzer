#!/usr/bin/env python
from http import server
import subprocess
import argparse
import sys
from pathlib import Path

def errprint(*args, **kwargs):
    print(*args, file=sys.stderr, **kwargs)

client_libraries_paths = "@CLIENT_LIBRARIES_FILES@"
client_compiler_flags = "-flto -fuse-ld=lld @CLIENT_NEEDED_COMPILATION_FLAGS@"
pass_path = "@FIZZER_PASS_FILE@"

server_path = "@SERVER_FILE@"
current_directory = Path().absolute()

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='TODO')
    parser.add_argument('file', metavar='file', help='Path to .c file to fuzz.')
    parser.add_argument('--clang', 
                        default="-O3", 
                        help=(
                            'Additional clang++ flags to use' 
                            'while compiling the client. ' 
                            'Use as --clang="options". Default is -O3'
                            ))
    parser.add_argument('--server',
                        default="",
                        help=(
                            'Options to pass to the server.'
                            'Use as --server="options"'
                            ))

    args = parser.parse_args()
    print(args)

    filename = Path(args.file).stem

    instrumented_file = filename + "_instrumented.ll"

    instrumentation = (
        "clang -flto -flegacy-pass-manager -Xclang -load -Xclang {0}"
        " -Xclang -disable-O0-optnone -fno-discard-value-names {1}"
        " -S -o {2}"
    ).format(pass_path, args.file, instrumented_file)

    print(instrumentation)
    instr_output = subprocess.run([instrumentation], shell=True)
    if instr_output.returncode:
        errprint("instrumentation of file c++ use same pipe or errorfailed")
        sys.exit(1)

    client_file = filename + "_client"

    client_compilation = "clang++ {0} {1} {2} {3} -o {4}".format(
        client_compiler_flags, client_libraries_paths, args.clang, 
        instrumented_file, client_file
    )

    print(client_compilation)
    client_compilation_output = subprocess.run([client_compilation], shell=True)
    if client_compilation_output.returncode:
        errprint("compilation of client failed")
        sys.exit(1)

    server_invocation = "{0} {1} --path_to_client {2}".format(
        server_path, args.server, current_directory / client_file
    )
    
    print(server_invocation)
    server_invocation_output = subprocess.run([server_invocation], shell=True)
    if server_invocation_output.returncode:
        errprint("running fuzzing failed")
        sys.exit(1)
    
